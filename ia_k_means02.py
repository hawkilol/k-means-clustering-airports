# -*- coding: utf-8 -*-
"""IA_K-means02.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yemLmNDQJTqbEgEUnvUL8rXpSntGAwgd
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# %matplotlib inline

# Fonte da base de dados: https://mapacep.com.br/index.php
# Link da base de dados no gist
url = 'https://gist.githubusercontent.com/hawkilol/9a5e64f50372346a35bb5098c59c7380/raw/7cdb42466b91704e474b9e7737ff22a7fd46e833/bairrosBelemNovo.csv'
df = pd.read_csv(url, usecols= ['Latitude','Longitude'])
dfBairros = pd.read_csv(url)
plt.scatter(df.Longitude, df.Latitude)
plt.show()

# Base de dados com os nomes dos bairros de belem com seus respectivos latitude(eixo Y) e longitude(eixo X)
dfBairros
#df

# Retorna as coordenas de um item do dict a partir de um indice
def coords(data, index):
  x = data.loc[index, 'Latitude']
  y = data.loc[index, 'Longitude']
  return x, y

# Distancia euclidiana
def eucDist(xa,xb,ya,yb):
  dist = np.sqrt((float(xa)-float(xb))**2 + (float(ya)-float(yb))**2)
  return dist



# #mean = centroid
# def UpdateMean(n, mean, item):
#   for i in range(len(mean)):
#     m = mean[i]
#     #calcula a media de cada agrupamento para determinar o seu centroide
#     m = (m*(n-1)+item[i])/float(n)
#     mean[i] = round(m, 3)
#   return mean

# Soma das distancias euclidianas entre as amostras e os centroides
def totalDist(centroids, tamanho_amostras, df, classes):
  dist = 0
  for f, coords_cent in centroids.items():
    x_centroid, y_centroid = coords_cent
    for amostra in range(tamanho_amostras):
      x_amostra, y_amostra = coords(df, amostra)
      dist += eucDist(x_amostra, x_centroid, y_amostra, y_centroid)
  return dist

def kMeans(K, df):
  # Numero total de amostras é o shape da base de dados
  nTotal_amostras = df.shape[0]

  #inicializa o dicionario inicial de centroides

  # Primeiro centroide(Val-de-Cans, 0)
  centroids = {0: coords(df, 0)}
  #K = 4
  for i in range(1, K):
    rand_amostra = np.random.randint(nTotal_amostras)
    centroids[i] =  coords(df, int(rand_amostra))
  
 

  # diferencia os centroids de forma aleatoria
  for i in range(K):
    for j in range(K):
      if i != j and j != 0:
        if centroids[i] == centroids[j]:
          rand_amostra = np.random.randint(nTotal_amostras)
          centroids[j] =  coords(df, int(rand_amostra))
          #centroids[len(centroids)] =  coords(df, int(rand_amostra))
          
 

   
  #classifica as amostras
  #inicializa as classes de acordo com número de means k 
  classes = {j: [] for j in range(K)}
  
  for i in range(nTotal_amostras*10):
    for n_amostra in range(nTotal_amostras):
      #reseta as distancias
      dists = []
      
      for f, coords_centroid in centroids.items():
        #escolhe os centroids com a menor distancia em relação as amostras
        x_centroid, y_centroid = coords_centroid
        x_amostra, y_amostra = coords(df, n_amostra)
        dists.append(eucDist(x_amostra, x_centroid, y_amostra, y_centroid))
        n_centroid = dists.index(min(dists))

     
        classes[n_centroid].append(n_amostra)

        
        
  #atualiza os centroids com base na classificação
  
    for classe in classes:
      #pula a atualização de centroid para o k do aeroporto de val de cans 0(colocado primeiro no dict centroids)
      if classe != 0:
        xs, ys = coords(df, classes[classe])
        
        x = np.average(xs)
        y = np.average(ys)
        centroids[classe] = (x, y)
        #UpdateMean()

  #print("Centroides:", centroids)
  #print("Amostras Classificadas:", classes)
  total_dist = totalDist(centroids, nTotal_amostras, df, classes)
  #print("Distancia Total:", total_dist)

  longitudes = [] # x
  latitudes = [] # y
  



  return classes, centroids, total_dist

classes, centroids, total_dist = kMeans(4, df)

list_dists = []
list_centroid = []
list_classes = []
table = []
data = []
for i in range(20):
  classes, centroid, total_dist = kMeans(4, df)

  list_dists.append(total_dist)
  list_centroid.append(centroid)
  list_classes.append(classes)
  data = [total_dist, centroid]
  table.append(data)

# melhor distancia
print(list_dists)
best_dist = min(list_dists)
print("Melhor distancia:", best_dist)

# escolhe os centroids da melhor clusterização para a plotagem 
best_run = list_dists.index(best_dist)
print("Numero da Melhor Clusterização:", best_run)
print("c", centroid)
print("cl", classes)
centroids = list_centroid[best_run]
classes = list_classes[best_run]

print("c", centroids)
print("cl", classes)

# escolhe os centroid da pior clusterização
worst_dist = max(list_dists)
print("Pior distancia:", worst_dist)
worst_run = list_dists.index(worst_dist)
print("Numero da pior Clusterização:", worst_run)

dataf = pd.DataFrame(table, columns = ["Distancia Total,", "Centroides"])
print(dataf)
datafTable = dataf.to_csv('bairros.csv')
dfData = pd.read_csv('bairros.csv')

datafTable
dfData

mapa_belem1_url = "https://drive.google.com/uc?export=view&id=15zrh4jGQ5iVAoKdN62t2D0oYnYOOXglI"
img1 = plt.imread(mapa_belem1_url)

mapa_belem_url = "https://drive.google.com/uc?export=view&id=1fLvDDPlyRNqC5uq-XCoulHk4Q_rYIZa1"

img = plt.imread(mapa_belem_url)

# Plotagem scatter das coordenadas das amostras e centroides no mapa de belem



plt.rcParams["figure.figsize"] = [32.00, 12.50]
plt.rcParams["figure.autolayout"] = True
colors=['blue', 'green', 'purple','orange']
#  X : Longitude: Y : Latitude:
data = img
x = df.Longitude
y = df.Latitude

nTotal_amostras = df.shape[0]
ext = [np.min(x),np.max(x), np.min(y), np.max(y)]
print(ext)
aspect=img.shape[0]/float(img.shape[1])*((ext[1]-ext[0])/(ext[3]-ext[2]))

im = plt.imshow(data, extent = ext, aspect = 'equal')

#x_points = []
#y_points = []

for i in range(nTotal_amostras):    
    for classe in classes:
        if i in classes[classe]: 
          plt.scatter(df.at[i,'Longitude'], df.at[i,'Latitude'],s=150, c = colors[classe])
for i in range(len(centroids)):
    plt.scatter(centroids[i][1], centroids[i][0], marker='x', c='red', s=150)

plt.show()

# Plotagem do pior
centroids = list_centroid[worst_run]
classes = list_classes[worst_run]
# Plotagem scatter das coordenadas das amostras e centroides no mapa de belem


plt.rcParams["figure.figsize"] = [32.00, 12.50]
plt.rcParams["figure.autolayout"] = True
colors=['blue', 'green', 'purple','orange']
#  X : Longitude: Y : Latitude:
data = img
x = df.Longitude
y = df.Latitude

nTotal_amostras = df.shape[0]
ext = [np.min(x),np.max(x), np.min(y), np.max(y)]
print(ext)
aspect=img.shape[0]/float(img.shape[1])*((ext[1]-ext[0])/(ext[3]-ext[2]))

im = plt.imshow(data, extent = ext, aspect = 'equal')

#x_points = []
#y_points = []

for i in range(nTotal_amostras):    
    for classe in classes:
        if i in classes[classe]: 
          plt.scatter(df.at[i,'Longitude'], df.at[i,'Latitude'],s=150, c = colors[classe])
for i in range(len(centroids)):
    plt.scatter(centroids[i][1], centroids[i][0], marker='x', c='red', s=150)

plt.show()

#h = sns.pairplot(df)



df

